<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COVID Wastewater Forecast</title>
    <link href="styles.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        /* Custom slider styles */
        input[type=range] {
            appearance: none;
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 1.3px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen font-sans text-gray-900">
    <div class="container mx-auto px-4 py-4">
        <h1 class="text-3xl font-bold mb-2 text-center">National COVID Wastewater Forecast</h1>
        <p class="text-center mb-4 text-gray-600">
            Holt-Winters model (52-week seasonality) with 50% confidence intervals.
            Select a cut-off date to see the forecast vs actuals.
        </p>

        <div class="bg-white rounded-lg shadow-lg p-6 relative">
            <div id="loading-overlay" class="fixed inset-0 bg-white/75 flex flex-col items-center justify-center z-50">
                <img src="loading.gif" alt="Loading..." class="w-16 h-16 mb-4">
                <p id="loading-text" class="text-lg font-semibold text-gray-700 text-center">Initializing...</p>
                <p class="text-sm text-gray-500">(This may take a minute or two.)</p>
            </div>

            <div id="chart" class="w-full h-[360px] mb-2"></div>
            
            <div class="relative w-full">
                <!-- Slider Container that will be aligned -->
                <div id="slider-container" class="w-full">
                    <input type="range" id="dateSlider" min="0" max="100" value="100" class="w-full" disabled>
                </div>
                <div class="text-center mt-2">
                    <label for="dateSlider" class="font-semibold text-lg">Forecast Cut-off Date:
                        <span id="cutoffDateLabel" class="text-blue-600"></span></label>
                </div>
                <p class="text-center mt-2 text-sm text-gray-500">Drag the slider to change the model training cut-off date. 
                    The upper 50% confidence interval region is bounded at an
                    <a href="https://www.cdc.gov/nwss/data-methods.html" class="text-blue-600 underline">activity level</a> of 30.</p>
            </div>
        </div>
        <p class="text-center mb-4 mt-8 text-gray-600">
            The code for this Pyodide-based app is <a href="https://github.com/jsalsman/covid-forecast"
                class="text-blue-600 underline">on GitHub</a>.
        </p>
    </div>

    <script>
        // --- Web Worker Code ---
        // Resolve base URL to ensure worker can find files relative to index.html
        const baseUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);

        const workerCode = `
            importScripts("${baseUrl}custom-pyodide/pyodide.js");

            function updateStatus(msg) {
                self.postMessage({ type: 'status', message: msg });
            }
            self.updateStatus = updateStatus;

            async function loadPyodideAndPackages() {
                self.updateStatus("Loading Pyodide...");
                self.pyodide = await loadPyodide({ indexURL: "${baseUrl}custom-pyodide/" });

                self.updateStatus("Unpacking packages...");
                const resp = await fetch("${baseUrl}custom-pyodide/packages.zip");
                const buf = await resp.arrayBuffer();

                try {
                    await self.pyodide.unpackArchive(buf, "zip", { extractDir: "/" });
                } catch (e) {
                    await self.pyodide.unpackArchive(buf, "zip", "/");
                }

                self.updateStatus("Importing pandas...");
                await self.pyodide.runPythonAsync("import pandas as pd");
                self.updateStatus("Importing statsmodels...");
                await self.pyodide.runPythonAsync("from statsmodels.tsa.holtwinters import ExponentialSmoothing");
                self.updateStatus("Imported packages...");
            }

            let pyodideReadyPromise = loadPyodideAndPackages();

            const pythonScript = \`
import pandas as pd
import numpy as np
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from pyodide.http import open_url
import json
import js

df = None

def get_data():
    global df
    url = "https://www.cdc.gov/wcms/vizdata/NCEZID_DIDRI/sc2/nwsssc2regionalactivitylevelDL.csv"
    try:
        # Load data
        df_raw = pd.read_csv(open_url(url))

        df_raw['Week_Ending_Date'] = pd.to_datetime(df_raw['Week_Ending_Date'])
        df_raw = df_raw.sort_values('Week_Ending_Date')

        # We only care about National_WVAL and Week_Ending_Date
        cleaned = df_raw[['Week_Ending_Date', 'National_WVAL']].dropna()

        # Drop duplicates to ensure unique index
        cleaned = cleaned.drop_duplicates(subset=['Week_Ending_Date'])

        cleaned = cleaned.set_index('Week_Ending_Date')

        try:
            cleaned.index.freq = pd.infer_freq(cleaned.index)
        except:
            pass

        df = cleaned

        # Prepare initial data for JS
        data = []
        for date, row in df.iterrows():
            val = row['National_WVAL']
            # Handle NaN/Inf
            if pd.isna(val) or np.isinf(val):
                val = None
            else:
                val = float(val)

            data.append({
                'date': date.strftime('%Y-%m-%d'),
                'value': val
            })
        return data
    except Exception as e:
        return {"error": str(e)}

def clean_val(v):
    if v is None: return None
    if isinstance(v, (float, np.float64, np.float32)):
        if np.isnan(v) or np.isinf(v): return None
    return float(v)

def run_forecast(cutoff_date_str):
    global df
    if df is None:
        return {"error": "Data not loaded"}

    if cutoff_date_str:
        cutoff_date = pd.to_datetime(cutoff_date_str)
        train_df = df[df.index <= cutoff_date]
    else:
        train_df = df

    # Model
    try:
        model = ExponentialSmoothing(
            train_df['National_WVAL'],
            seasonal_periods=52,
            trend='add',
            seasonal='add',
            damped_trend=True,
            use_boxcox=True,
            initialization_method="estimated"
        )
        model_fit = model.fit()
    except Exception as e:
        # Fallback
        model = ExponentialSmoothing(
            train_df['National_WVAL'],
            seasonal_periods=52,
            trend='add',
            seasonal='add'
        )
        model_fit = model.fit()

    forecast_steps = 52
    forecast = model_fit.forecast(forecast_steps)

    # Confidence Intervals via Simulation
    n_simulations = 500
    simulations = np.zeros((forecast_steps, n_simulations))

    prev_lower = None
    prev_upper = None

    for i in range(n_simulations):
        if (i + 1) % 10 == 0:
            js.updateStatus(f"Ran {i+1} Monte Carlo simulations for confidence intervals...")
        sim = model_fit.simulate(forecast_steps, anchor='end')
        simulations[:, i] = sim.values

        if (i + 1) % 10 == 0:
            current_sims = simulations[:, :i+1]
            current_lower = np.nanpercentile(current_sims, 25, axis=1)
            current_upper = np.nanpercentile(current_sims, 75, axis=1)

            if prev_lower is not None and prev_upper is not None:
                diff_lower = np.mean(np.abs(current_lower - prev_lower) / (np.abs(prev_lower) + 1e-9))
                diff_upper = np.mean(np.abs(current_upper - prev_upper) / (np.abs(prev_upper) + 1e-9))
                mean_diff = (diff_lower + diff_upper) / 2

                if mean_diff < 0.05:
                    js.updateStatus(f"Converged at {i+1} simulations. Stopping.")
                    simulations = simulations[:, :i+1]
                    break

            prev_lower = current_lower
            prev_upper = current_upper

    lower_bound = np.nanpercentile(simulations, 25, axis=1)
    upper_bound = np.nanpercentile(simulations, 75, axis=1)

    upper_bound = np.minimum(upper_bound, 30)

    forecast_data = []
    last_date = train_df.index[-1]

    for i in range(forecast_steps):
        next_date = last_date + pd.Timedelta(weeks=i+1)
        forecast_data.append({
            'date': next_date.strftime('%Y-%m-%d'),
            'forecast': clean_val(forecast.iloc[i]),
            'lower': clean_val(lower_bound[i]),
            'upper': clean_val(upper_bound[i])
        })

    return {
        'forecast': forecast_data,
        'cutoff_date': train_df.index[-1].strftime('%Y-%m-%d')
    }
\`;

            self.onmessage = async (event) => {
                await pyodideReadyPromise;
                const { type, payload } = event.data;

                if (type === 'init') {
                    // Initialize Python environment
                    await self.pyodide.runPythonAsync(pythonScript);

                    // Fetch data
                    const result = await self.pyodide.runPythonAsync("get_data()");
                    const data = result.toJs({dict_converter: Object.fromEntries});
                    self.postMessage({ type: 'init_result', data: data });
                } else if (type === 'forecast') {
                    const date = payload;
                    self.pyodide.globals.set("target_date", date);
                    const result = await self.pyodide.runPythonAsync("run_forecast(target_date)");
                    const data = result.toJs({dict_converter: Object.fromEntries});
                    self.postMessage({ type: 'forecast_result', data: data });
                }
            };
        `;

        // --- Main UI Logic ---
        const blob = new Blob([workerCode], { type: "text/javascript" });
        const worker = new Worker(URL.createObjectURL(blob));

        let allData = [];
        let dates = [];

        // UI References
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const slider = document.getElementById('dateSlider');
        const cutoffLabel = document.getElementById('cutoffDateLabel');
        const chartDiv = document.getElementById('chart');

        worker.onmessage = (event) => {
            const { type, data, message } = event.data;
            if (type === 'status') {
                loadingText.innerText = message;
            } else if (type === 'init_result') {
                if (data.error) {
                    console.error("Python Init Error:", data.error);
                    loadingText.innerText = "Error loading data.";
                    return;
                }
                loadingText.innerText = "Rendering initial chart...";
                initChart(data);
            } else if (type === 'forecast_result') {
                updateChartWithForecast(data);
            }
        };

        // Start initialization
        worker.postMessage({ type: 'init' });

        function initChart(data) {
            if (!data) return;
            allData = data;
            dates = allData.map(d => d.date);
            
            // Set slider range
            const minIndex = 104; // Keep the 104 week constraint
            if (dates.length > minIndex) {
                slider.min = minIndex;
            } else {
                slider.min = 0;
            }
            slider.max = dates.length - 1;
            slider.value = dates.length - 1;
            slider.disabled = false;
            
            // Initial Forecast
            requestForecast(dates.length - 1);
            
            slider.addEventListener('input', (e) => {
                const index = parseInt(e.target.value);
                cutoffLabel.innerText = dates[index];
            });

            slider.addEventListener('change', (e) => {
                const index = parseInt(e.target.value);
                requestForecast(index);
            });

            window.addEventListener('resize', () => {
                Plotly.Plots.resize(chartDiv).then(alignSlider);
            });
        }

        function requestForecast(cutoffIndex) {
            loadingOverlay.classList.remove('hidden');
            loadingOverlay.classList.add('flex');
            loadingText.innerText = "Calculating Forecast...";

            const cutoffDate = dates[cutoffIndex];
            cutoffLabel.innerText = cutoffDate;

            worker.postMessage({ type: 'forecast', payload: cutoffDate });
        }

        function updateChartWithForecast(forecastData) {
            if (forecastData.error) {
                console.error("Forecast Error:", forecastData.error);
                loadingOverlay.classList.add('hidden');
                loadingOverlay.classList.remove('flex');
                return;
            }

            const cutoffDateStr = forecastData.cutoff_date;
            const cutoffIndex = dates.indexOf(cutoffDateStr);

            const trainData = allData.slice(0, cutoffIndex + 1);
            const testData = allData.slice(cutoffIndex + 1);

            const trainDates = trainData.map(d => d.date);
            const trainValues = trainData.map(d => d.value);

            const testDates = testData.map(d => d.date);
            const testValues = testData.map(d => d.value);

            const forecastDates = forecastData.forecast.map(d => d.date);
            const forecastValues = forecastData.forecast.map(d => d.forecast);
            const lowerBound = forecastData.forecast.map(d => d.lower);
            const upperBound = forecastData.forecast.map(d => d.upper);

            const traces = [
                // Lower Bound
                {
                    x: forecastDates,
                    y: lowerBound,
                    type: 'scatter',
                    mode: 'lines',
                    line: { width: 0 },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                // Upper Bound (Filled)
                {
                    x: forecastDates,
                    y: upperBound,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: 'rgba(37, 99, 235, 0.2)',
                    line: { width: 0 },
                    name: '50% Confidence Interval',
                    hoverinfo: 'skip'
                },
                // Actual Future
                {
                    x: testDates,
                    y: testValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Actual',
                    line: { color: '#1f2937', width: 2, dash: 'dot' }
                },
                // Forecast
                {
                    x: forecastDates,
                    y: forecastValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Forecast',
                    line: { color: '#2563eb', width: 3 }
                },
                // History
                {
                    x: trainDates,
                    y: trainValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'History',
                    line: { color: '#1f2937', width: 2 }
                },
            ];

            const layout = {
                yaxis: { title: 'Wastewater Viral Activity Level' },
                hovermode: 'x',
                dragmode: false,
                showlegend: true,
                legend: { orientation: 'h', y: 1.1 },
                margin: { t: 0, b: 25, l: 40, r: 0 }
            };

            Plotly.react('chart', traces, layout, { displayModeBar: false }).then(() => {
                alignSlider();
                loadingOverlay.classList.add('hidden');
                loadingOverlay.classList.remove('flex');
            });
            
             // Also align on relayout (zoom/pan)
            chartDiv.on('plotly_relayout', function(){
                alignSlider();
            });
        }

        function alignSlider() {
            if (!chartDiv || !chartDiv._fullLayout) return;

            const xaxis = chartDiv._fullLayout.xaxis;
            const margin = chartDiv._fullLayout.margin;
            
            if (dates.length === 0) return;

            const minIndex = parseInt(slider.min) || 0;
            const maxIndex = parseInt(slider.max) || (dates.length - 1);

            const startDate = dates[minIndex];
            const endDate = dates[maxIndex];
            
            // Calculate pixels relative to the plot area
            let startPx = xaxis.c2p(startDate);
            let endPx = xaxis.c2p(endDate);
            
             // Fallback to timestamp if needed
            if (startPx === undefined || isNaN(startPx)) {
                 startPx = xaxis.c2p(new Date(startDate).getTime());
            }
            if (endPx === undefined || isNaN(endPx)) {
                 endPx = xaxis.c2p(new Date(endDate).getTime());
            }
            
            const leftOffset = margin.l + startPx;
            const width = endPx - startPx;
            
            const sliderContainer = document.getElementById('slider-container');
            
            // Apply styles
            if (width > 0) {
                 sliderContainer.style.marginLeft = `${leftOffset}px`;
                 sliderContainer.style.width = `${width}px`;
            }
        }
    </script>
</body>
</html>
